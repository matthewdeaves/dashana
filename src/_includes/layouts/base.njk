<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  <title>{{ title }} | {{ config.projectName }}</title>
  <link rel="stylesheet" href="{{ pathPrefix }}/css/styles.css">
  <link rel="stylesheet" href="{{ pathPrefix }}/css/print.css" media="print">
  <script>
    (function() {
      var theme = localStorage.getItem('theme');
      if (theme === 'dark') {
        document.documentElement.classList.add('dark');
      } else if (theme === 'light') {
        document.documentElement.classList.add('light');
      } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.classList.add('dark');
      }
    })();
  </script>
</head>
<body>
  {% include "components/header.njk" %}
  <main>
    {{ content | safe }}
  </main>
  <script>
    var themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
      themeToggle.addEventListener('click', function() {
        var html = document.documentElement;
        var isDark = html.classList.contains('dark');
        html.classList.remove('dark', 'light');
        if (isDark) {
          html.classList.add('light');
          localStorage.setItem('theme', 'light');
        } else {
          html.classList.add('dark');
          localStorage.setItem('theme', 'dark');
        }
      });
    }

    var filterToggle = document.getElementById('filter-toggle');
    if (filterToggle) {
      // Restore filter state from localStorage
      var filterState = localStorage.getItem('filterOpenOnly');
      if (filterState === 'true') {
        filterToggle.classList.add('show-open-only');
        filterToggle.setAttribute('aria-pressed', 'true');
        document.body.classList.add('show-open-only-active');
      }

      filterToggle.addEventListener('click', function() {
        var isFiltered = filterToggle.classList.toggle('show-open-only');
        filterToggle.setAttribute('aria-pressed', isFiltered);
        document.body.classList.toggle('show-open-only-active', isFiltered);
        localStorage.setItem('filterOpenOnly', isFiltered);
      });
    }

    var versionSelect = document.getElementById('version-select');
    if (versionSelect) {
      versionSelect.addEventListener('change', function() {
        window.location.href = this.value;
      });
    }

    // Tooltip position detection - flip below when not enough room above
    // Tooltip max-height is 200px + margin, check against viewport top
    document.querySelectorAll('.notes-icon').forEach(function(icon) {
      function updatePosition() {
        var rect = icon.getBoundingClientRect();
        icon.classList.toggle('tooltip-below', rect.top < 300);
      }
      icon.addEventListener('mouseenter', updatePosition);
      icon.addEventListener('focus', updatePosition);
    });

    // Mobile tooltip - real DOM element with fixed positioning (QA-005)
    // Avoids iOS Safari focus issues and doesn't break table scroll
    (function() {
      var isTouch = 'ontouchstart' in window;
      if (!isTouch) return;

      // Disable CSS :focus tooltips on touch devices (JS handles it)
      document.documentElement.classList.add('touch-device');

      var triggers = '.notes-icon, .notes-text-preview, .card-notes-icon';
      var activeTrigger = null;
      var tooltip = null;

      function getTooltip() {
        if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.className = 'mobile-tooltip';
          document.body.appendChild(tooltip);
        }
        return tooltip;
      }

      function showTooltip(trigger) {
        // Remove focus to hide CSS :focus::after tooltip (prevents double tooltip)
        trigger.blur();

        var el = getTooltip();
        var notes = trigger.getAttribute('data-notes');
        var rect = trigger.getBoundingClientRect();

        el.textContent = notes;
        el.style.display = 'block';

        // Measure tooltip dimensions
        var tooltipRect = el.getBoundingClientRect();
        var spaceAbove = rect.top;
        var spaceBelow = window.innerHeight - rect.bottom;

        // Position vertically - prefer below, flip if needed
        if (spaceBelow >= tooltipRect.height + 10 || spaceBelow > spaceAbove) {
          el.style.top = (rect.bottom + 8) + 'px';
        } else {
          el.style.top = (rect.top - tooltipRect.height - 8) + 'px';
        }

        // Center horizontally, constrain to viewport
        var left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        left = Math.max(10, Math.min(left, window.innerWidth - tooltipRect.width - 10));
        el.style.left = left + 'px';

        activeTrigger = trigger;
      }

      function hideTooltip() {
        if (tooltip) tooltip.style.display = 'none';
        activeTrigger = null;
      }

      document.addEventListener('click', function(e) {
        var trigger = e.target.closest(triggers);

        if (trigger) {
          e.preventDefault(); // Prevent any default link behavior
          if (activeTrigger === trigger) {
            hideTooltip();
          } else {
            showTooltip(trigger);
          }
        } else {
          hideTooltip();
        }
      });
    })();

    // Dismiss on Escape key (accessibility - WCAG 1.4.13)
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        document.activeElement.blur();
      }
    });
  </script>
</body>
</html>
